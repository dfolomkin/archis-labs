# Основные моменты JavaScript

## Быстрый переход

- [Введение](##-Введение)

- [Пример синтаксиса](##-Пример-синтаксиса)

- [Типы данных](##-Типы-данных)

- [Операции](##-Операции)

- [Типы операторов](###-Типы-операторов)

- [Приведение типов](###-Приведение-типов)

- [Передача ссылки или значения](###-Передача-ссылки-или-значения)

- [Ветвления](##-Ветвления)

- [1 Оператор if](###-1-Оператор-if)

- [2 Оператор switch](###-2-Оператор-switch)

- [Циклы](##-Циклы)

- [1 Цикл с параметром (for)](<###-1-Цикл-с-параметром-(for)>)

- [2 Цикл с пост-условием (while)](<###-2-Цикл-с-пост-условием-(while)>)

- [3 Цикл с предусловием (do while)](<###-3-Цикл-с-предусловием-(do-while)>)

- [Функции](##-Функции)

- [Структуры данных](##-Структуры-данных)

- [1 Строка](###-1-Строка)

- [Свойства и методы строк](####-Свойства-и-методы-строк)

- [2 Массив](###-2-Массив)

- [Свойства и методы массивов](####-Свойства-и-методы-массивов)

- [3 Объект](###-3-Объект)

- [ООП и Классы](##-ООП-и-Классы)

- [Асинхронный JS: callback и promise](##-Асинхронный-JS:-callback-и-promise)

- [Обработка ошибок (try ... catch)](<##-Обработка-ошибок-(try-...-catch)>)

- [Информационные ресурсы](###-Информационные-ресурсы)

## Введение

JavaScript (JS) - мультипарадигменный язык программирования. Поддерживает объектно-ориентированный, императивный и функциональный стили. Является реализацией языкового стандарта ECMAScript (ES), поэтому различные версии JS в зависимости от года утверждения стандарта называются ES5, ES6 (ES2015), ES7 (ES2016) и т.д.

Основные архитектурные черты: динамическая типизация, слабая типизация, автоматическое управление памятью, прототипное программирование, функции как объекты первого класса.

JS обычно используется в браузерах для придания интерактивности веб-страницам. Однако, в данной работе будем рассматривать серверный JS, работающий на программной платформе Node.js.

Файлы с JS-кодом обычно имеют расширение .js.

JS считается интерпретируемым (на самом деле тут все не так однозначно) - каждая отдельная операция переводится в байт-код (JIT-компилятором, поэтому и неоднозначно) и сразу же выполняется движком JS.

## Пример синтаксиса

```
// инициализация переменных
var h = 'hello';
var w = 'world';

// вычисление
var hw = h + ' ' + w;

// вывод результата в консоль
console.log(hw + '!'); // hello world!
```

Ключевое слово `var` (`let`, `const` в ES6) служит для объявления переменных.

Cимвол `;` позволяет разделять операции.

Строки, помеченные `//`, являются комментариями для разработчика и не обрабатываются движком JS.

Метод `console.log()` выводит информацию в консоль.

В данном руководстве коментарий `//` после `console.log()` показывает выводимый в консоль результат.

Например, `console.log('hello world') // hello world` показывает, что в консоль выведется строка hello world.

- В JS принято использовать нотацию **camelCase** практически для всех имен: переменных, функций, полей и методов объекта и т.д. (var newVariable, function getCountOfSomething(), { firstName: 'John' }, ...). Но для имен конструкторов или классов используется нотация **PascalCase** (class Fruit или Fruit()).

## Типы данных

JS - язык программирования с **нестрогой** **динамической** типизацией. "Динамическая" типизация означает в частности, что тип данных какой-либо переменной может изменяться по ходу выполнения программы. "Нестрогая" типизация в частности позволяет заранее не задавать тип данных, а выводить его автоматически в процессе выполнения программы.

В JS существует 6 типов данных (7 в ES6):

- number

- string

- boolean

- null

- undefined

- object

Оператор `typeof` возвращает тип значения (string) следующей за оператором переменной.

1. Число - number

```
var n = 123;
n = 12.345;
console.log(typeof n); // number
```

При ошибках, связанных с приведением типов, можно получить специальное значение NaN (not a number). Оно типом не является, но `typeof NaN` как ни странно возвращает number - это особенность языка!

2. Строка - string

Значение строкового типа записывается в кавычках '' (этот вариант предпочтительнее) или "".

```
var s = 'hello';
s = 'hello world';
console.log(typeof s); // string
```

3. Логический (булевый) тип - boolean

```
var b = true;
b = false;
console.log(typeof b); // boolean
```

4. Специальное значение - null

`typeof null` возвращает object - особенность языка.

```
var spec = null;
console.log(typeof n); // object
```

5. Специальное значение - undefined

Имеет смысл "значение не присвоено". При объявлении переменной без присвоения значения ее значение будет undefined.

```
var spec;
console.log(spec); // undefined
spec = 'some value';
console.log(spec); // some value
```

Но undefined можно присвоить и принудительно.

```
var spec = undefined;
console.log(spec); // undefined
```

Типы (1-5) - примитивные типы.

6. Объект - object

подробнее см. [3. Объект](###-3.-Объект)

```
var n = {
  firstName: 'John',
  lastName: 'Doe'
};
console.log(typeof n); // object
```

## Операции

### Типы операторов

**Бинарные** требуют 2 операнда.

Арифметические операторы используются с числами (тип number):

```
var sum = a + b; // бинарный плюс
var diff = a - b; // бинарный минус
var mult = a * b;
var div = a / b;
var c = a % b; // остаток от деления a на b
```

Бинарный плюс также используется для конкатенации (склеивания) строк (тип string):

```
var res = 'hello' + ' ' + 'world';
console.log(res); // hello world
```

Логические операторы используются с логическими значениями (тип boolean) (или с другими типами, неявно приводящимися к логическим):

```
var res = a && b; // логическое И
var res = a || b; // логическое ИЛИ
```

Операторы сравнения используются с разными типами данных (в т.ч. разными типами для каждого операнда, неявно приводящимися к одному типу), но всегда возвращают тип boolean:

```
var res = a < b;
var res = a <= b;
var res = a > b;
var res = a >= b;
var res = a == b; // "равно"
var res = a != b; // "неравно"
var res = a === b; // строгое "равно"
var res = a !== b; // строгое "неравно"
```

При использовании обычного "равно"/"неравно" происходит неявное [Приведение типов](###-Приведение-типов):

```
console.log(12 == '12') // true
console.log(0 == null) // true
```

При использовании строгого "равно"/"неравно" значения проверяются с учетом типов:

```
console.log(12 === '12') // false
console.log(0 === null) // false
```

NaN - единственное значение, которое строго неравно самому себе:

```
console.log(12 === 12) // true
console.log(NaN === NaN) // false
```

Логические операторы и операторы сравнения особенно заметно используют неявное [Приведение типов](###-Приведение-типов).

**Унарные** требуют одного операнда:

```
var num = +'12' // унарный плюс для преобразования к числу
var num = -12 // унарный минус
var res = !false; // логическое НЕ
```

Унарными являются сокращенные варианты основных арифметических операций:

```
var sum += a; // равносильно sum = sum + a;
var diff -= a; // равносильно diff = a - b;
var mult *= a; // равносильно mult = a * b;
var div /= a; // равносильно div = a / b;
```

в том числе и инкремент/декремент значения:

```
a++; // равносильно a += 1 или  a = a + 1
a--; // равносильно a -= 1 или  a = a - 1
```

Унарным является оператор **присваивания** `=`.

**Тернарный** (один единственный в JS и по совместительству условный) - требуeт 3-х операндов. Используется, когда нужно получить то или иное значение в зависимости от истинности условия:

```
var a = predicat ? value1 : value2;
```

Такая конструкция аналогично ветвлению с [Оператор if](###-Оператор-if):

```
var a;
if (predicat) {
  a = value1;
} else {
  a = value2;
}
```

### Приведение типов

В процессе выполнения различных операций происходит **неявное** приведение типов (привет **нестрогой** типизации JS).

Например, при сложении двух операндов, если один из них является строкой (тип string), результат также приводится к строке:

```
var res = 2 + '2';
console.log(res); // '22'
console.log(typeof res); // string
var res = '2' + 2;
console.log(res); // '22'
console.log(typeof res); // string
```

TODO другие примеры приведения типов

Кроме того JS позволяет **явно** приводить типы с помощью конструкторов:

```
var num = Number('12'); // приведется к числу 12
var str = String(12); // приведется к строке '12'
var bool = Boolean('whatever'); // true
var bool = Boolean(''); // false
```

Также **явно** приводить типы можно с помощью некоторых операторов:

Унарный плюс приводит строку к числу:

```
var num = +'12'; // приведется к числу 12
```

Логическое НЕ приводит любое "нулевое" (0, '', null, undefined) значение к true:

```
var bool = !0; // число 0 приводится к true
var bool = !''; // непустая строка приводится к true
```

а "ненулевое" значение к false:

```
var bool = !12; // число 12 приводится к false
var bool = !'some string'; // непустая строка приводится к false
```

Для приведения любого "ненулевого значения" к true можно использовать двойное логическое НЕ.

```
console.log(!!12); // true
console.log(!!'some string'); // true
```

### Передача ссылки или значения

## Ветвления

### 1 Оператор if

### 2 Оператор switch

## Циклы

### 1 Цикл с параметром (for)

### 2 Цикл с пост-условием (while)

### 3 Цикл с предусловием (do while)

## Функции

TODO области видимости, замыкание

## Структуры данных

### 1 Строка

Строго говоря, строка - это примитив. Однако, ее сущность (состоит из символов) позволяет говорить о ней, как о структуре.

#### Свойства и методы строк

Несмотря на то, что строка - примитив, в JS специальный неявный механизм (**boxing**), который позволяет использовать у примитива методы, прямо как у объекта.

`str[index]` - возвращает один символ строки str с индексом index

```
var str = 'hello';
console.log(str[5]); // o
```

`str.charAt(index)` - делает то же самое, но в отличии от `str[index]` работает и в старых браузерах (IE6).

Строки **иммутабельны**: **нельзя** присвоить значение отдельному символу существующей строки!

`.length` - возвращает длину строки

```
var str = 'hello';
console.log(str.length); // 5
```

`.toLowerCase()`/`.toUpperCase()` - возвращает строку в нижнем/верхнем регистре

```
var str = 'Hello WORLD';
console.log(str.toLowerCase()); // hello world
console.log(str.toUpperCase()); // HELLO WORLD
```

`.slice(start, end)` и `.substring(start, end)` - возвращает подстроку начиная с символа с индексом start и заканчивая (но не включая!) символом с индексом end

```
var str = 'hello world';
var subStr = str.slice(0, 5);
console.log(subStr); // hello

var subStr = str.substring(0, 5);
console.log(subStr); // hello
```

Если второй аргумент не задан, то подстрока считается до конца исходной строки.

```
var str = 'hello world';
var subStr = str.slice(7);
console.log(subStr); // world
```

В качестве аргументов `.slice()` разрешается задавать отрицательные значения, тогда отсчет символов будет осуществляться с конца строки.

```
var str = 'hello world';
var subStr = str.slice(-5);
console.log(subStr); // world
```

Аргументы (индексы начального и конечного символа) `.substring()` разрешается менять местами без последствий.

```
var str = 'hello world';
var subStr = str.slice(5, 0);
console.log(subStr); // hello
```

`.substr(start, length)` - возвращает подстроку длинной length символов начиная с символа с индексом start

```
var str = 'hello world';
var subStr = str.substr(1, 4);
console.log(subStr); // hello
```

`.substr()` может работать с одним аргументом и с отрицательными значениями.

`.indexOf(subStr)` - возвращает индекс начального символа **первого** вхождения подстроки subStr в исходную строку, или -1, если вхождений не найдено

```
var str = 'hello world';
console.log(str.indexOf('world')); // 7
console.log(str.indexOf('hi')); // -1
```

`.concat(addStr)` - возвращает строку, полученную путем добавления аргумента addStr в конец исходной строки

```
var str = 'hello';
var newStr = str.concat(' world');
console.log(newStr); // hello world
```

Альтернатива использованию бинарного плюса со строками.

```
console.log('hello' + 'world'); // hello world
```

`.split(divider)` - возвращает массив, полученный разрезанием строки по символу divider

```
var str = 'hello world';
var arr = str.split(' ');
console.log(arr); // ['hello', 'world']
```

### 2 Массив

Массив - **упорядоченная** структура, которая может содержать в себе данные любых типов, в т.ч. объекты и другие массивы.

```
var ports = [27001, 3017, 9017];
var clients = [
  {name: 'John Doe', age: 25},
  {name: 'Jon Snow', age: 35},
  {name: 'John Wick', age: 50}
];
var complexArray = [[1, 2], [3, 4]];
```

#### Свойства и методы массивов

`arr[index]` - возвращает значение элемента с индексом index массива arr.

Массивы **мутабельны**, можно присвоить новое значение любому элементу, обратившись по индексу.

```
var clients = ['John Doe', 'Jon Snow', 'John Wick'];
var clientName = clients[0];
console.log(clientName); // John Doe

clients[1] = 'John Travolta';
console.log(clients); // ['John Doe', 'John Travolta', 'John Wick']
```

`.length` - возвращает размер массива

```
var clients = ['John Doe', 'Jon Snow', 'John Wick'];
var arrLength = clients.length;
console.log(arrLength); // 3
```

Все методы массивов можно разделить на 2 группы по принципу мутабельности.

##### Мутабельные (изменяют исходный массив)

`.push(newElement)`/`.unshift(newElement)` - добавляет новый элемент или **массив элементов** newElement в конец/начало массива и возвращает этот элемент или массив элементов

```
var clients = ['John Doe', 'Jon Snow', 'John Wick'];
clients.push('John Travolta'); // John Travolta
console.log(clients); // ['John Doe', 'Jon Snow', 'John Wick', 'John Travolta']
```

```
var clients = ['John Doe', 'Jon Snow', 'John Wick'];
clients.unshift('John Travolta'); // John Travolta
console.log(clients); // ['John Travolta','John Doe', 'Jon Snow', 'John Wick']
```

`.pop()`/`.shift()` - удаляет последний/первый элемент массива и возвращает этот элемент

```
var clients = ['John Doe', 'Jon Snow', 'John Wick'];
clients.pop('John Wick'); // John Wick
console.log(clients); // ['John Doe', 'Jon Snow']
```

```
var clients = ['John Doe', 'Jon Snow', 'John Wick'];
clients.shift('John Doe'); // John Doe
console.log(clients); // ['Jon Snow', 'John Wick']
```

`.splice(start, count)` - вырезает подмассив длинной count элементов начиная с элемента с индексом start и возвращает вырезанный подмассив

```
var clients = ['John Doe', 'Jon Snow', 'John Wick', 'John Travolta'];
clients.splice(1, 2); // ['Jon Snow', 'John Wick']
console.log(clients); // ['John Doe', 'John Travolta']
```

`.splice(start, count, newElement)` - в таком виде метод позволяет добавить новый элемент или **массив элементов** newElement вместо вырезанной части

```
var clients = ['John Doe', 'Jon Snow', 'John Wick', 'John Travolta'];
clients.splice(1, 2, ['Johnny Storm', 'Johnny Cage']);
console.log(clients); // ['John Doe', 'Johnny Storm', 'Johnny Cage', 'John Travolta']
```

`.reverse()` - обращает порядок элементов массива и возвращает измененный массив

```
var clients = ['John Doe', 'Jon Snow', 'John Wick'];
clients.reverse(); // ['John Wick', 'Jon Snow', 'John Doe']
console.log(clients); // ['John Wick', 'Jon Snow', 'John Doe']
```

`.sort(fn)` - сортирует массив в соответствии с функцией-компаратором fn, которая задается пользователем, и возвращает отсортированный массив

Например, чтобы отсортировать массив чисел по возрастанию, нужно написать такой компаратор:

```
var numbers = [12, 1, 2, 42, 5];
var comparator = function(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}
var sortedNumbers = numbers.sort(comparator);
console.log(numbers); // [1, 2, 5, 12, 42]
console.log(sortedNumbers); // [1, 2, 5, 12, 42]
```

##### Иммутабельные (не изменяют исходный массив, а возвращают новый)

`.slice(start, end)` - возвращает подмассив начиная с элемента с индексом start и заканчивая (но не включая!) элементом с индексом end

Иммутабельная альтернатива (для получения подмассива, не для замены) .splice().

```
var clients = ['John Doe', 'Jon Snow', 'John Wick', 'John Travolta'];
var newClients = clients.slice(1,3);
console.log(newClients); // ['Jon Snow', 'John Wick']
console.log(clients); // ['John Doe', 'Jon Snow', 'John Wick', 'John Travolta']
```

`.map(fn)` - возвращает массив, полученный преобразованием каждого элемента исходного массива функцией fn

fn принимает три аргумента (элемент массива, индекс элемента (опция), исходный массив (опция)) и возвращает новый элемент массива. Количество элементов в результирующем массиве такое же, как и в исходном.

```
var clients = ['John Doe', 'Jon Snow', 'John Wick', 'John Travolta'];
var nameLength = clients.map(function(item, index, arr) {
  return item.length;
});
console.log(nameLength); // [8, 8, 9, 13]
```

`.filter(fn)` - возвращает массив, полученный путем отбора элементов исходного массива в соответствии с предикатом fn, или пустой массив, если ничего не соответствует предикату fn

fn принимает три аргумента (элемент массива, индекс элемента (опция), исходный массив (опция)) и возвращает true, если элемент нужно включать в результирующий массив, или false, если не нужно.

```
var clients = ['John Doe', 'Jon Snow', 'John Wick', 'John Travolta'];
var trueJohnsOnly = clients.filter(function(item, index, arr) {
  return item.indexOf('John') !== -1;
});
console.log(trueJohnsOnly); // ['John Doe', 'John Wick', 'John Travolta']
```

`.find(fn)` - возвращает первый найденный в соответствии с предикатом fn элемент массива или undefined, если ничего не найдено

```
var clients = ['John Doe', 'Jon Snow', 'John Wick', 'John Travolta'];
var client = clients.find(function(item, index, arr) {
  return item.indexOf('Snow') !== -1;
});
console.log(client); // Jon Snow
```

`findIndex(fn)` - возвращает **индекс** первого найденного в соответствии с предикатом fn элемент массива или undefined, если ничего не найдено

```
var clients = ['John Doe', 'Jon Snow', 'John Wick', 'John Travolta'];
var clientIndex = clients.findIndex(function(item, index, arr) {
  return item.indexOf('Snow') !== -1;
});
console.log(clientIndex); // 1
```

`.indexOf(subArr)` - возвращает индекс начального элемента **первого** вхождения аргумента subArr (элемент или массив элементов) в исходный массив, или -1, если вхождений не найдено

```
var clients = ['John Doe', 'Jon Snow', 'John Wick', 'John Travolta'];
console.log(clients.indexOf('Jon Snow')); // 1
console.log(clients.indexOf('Jonny Cage')); // -1
```

`.concat(addArr)` - возвращает массив, полученный путем добавления аргумента addArr (элемент или массив элементов) в конец исходного массива

Иммутабельная альтернатива .push().

```
var clients = ['John Doe', 'Jon Snow', 'John Wick'];
var newClients = clients.concat('John Travolta');
console.log(clients); // ['John Doe', 'Jon Snow', 'John Wick']
console.log(newClients); // ['John Doe', 'Jon Snow', 'John Wick', 'John Travolta']
```

`.join(divider)` - возвращает строку, полученную путем склейки элементов массива и символа divider между ними

```
var arr = ['hello', 'world'];
var str = arr.join(' ');
console.log(str); // 'hello world'
```

`Array.isArray(arr)` - возвращает true, если arr является массивом. При этом `typeof arr` вернет object

#### Обход элементов массива

1. Цикл for

2. Метод `.forEach(fn)` - для каждого элемента массива вызвать ф-ию fn

3. Методы `.map(fn)` и `.filter(fn)`

### 3 Объект

Объект - структура данных, представляющая собой набор пар свойство-значение.

```
var client = {
  name: 'John Doe',
  age: 30
};
```

Значения могут быть любых типов, в т.ч. и другие "вложенные" объекты, и даже функции (при этом их называют методы).

Доступ к свойству осуществляется с помощью символа `.` или конструкции `['propName']`, где propName - имя свойства.

```
client.name = 'Jon Snow';
console.log(client.name); // Jon Snow
console.log(client['name']); // Jon Snow
```

TODO this в объекте, методы объекта

## ООП и Классы

TODO конструктор, new, this, proto, class (ES6)

## Асинхронный JS: callback и promise

**Функция обратного вызова** (**Сallback**) - любая функция, которая передается в другую функцию в качестве аргумента, и там может быть вызвана.

Например, вот колбэк который выводит значение параметра в консоль:

```
function callMeMaybe(str) {
  console.log(str);
}
```

а вот функция, принимающая колбэк в качестве аргумента и вызывающая его:

```
function wrapper(fn) {
  var message = 'hello world';
  fn(message); // вызываем колбэк cо значением параметра 'hello world'
}
```

Вызываем функцию-обертку:

```
wrapper(callMeMaybe);
```

и получаем 'hello world' в консоли.

В качестве колбэка чаще передают анонимные функции (без имени):

```
wrapper(function(str) {
  console.log(str);
});
```

Смысл колбэка в том, чтобы вызвать функцию только при определенных условиях.

Например, в методе массивов .forEach() переданный колбэк вызывается при обходе массива на каждом его элементе:

```
  var arr = [1, 2, 3];
  arr.forEach(function(item) {
    console.log(item);
  });
```

Причем это условие может наступить как "мгновенно", когда выполняется текущая строка программы (как в случае с .forEach()), так и "когда-нибудь потом".

Во втором случае речь идет об **асинхронных операциях**, например, о запросах на сервер. Серверу требуется какое-то время для обработки запроса, но основная программа не может простаивать, так как это заблокирует любые другие операции (например, обработку манипуляций с интерфейсом в браузере).

Смысл асинхронной операции в том, что основная программа запускает ее и продолжает выполнять другие операции. Как только асинхронная операция завершится каким-либо результатом (в т.ч. ошибкой), основная программа вернется для обработки этого результата и вызовет переданный колбэк. Поскольку в качестве результата может вернуться другая асинхронная операция, в результате которой снова нужно вызвать уже другой колбэк и т.д., то получается примерно следующая конструкция:

```
  wrapper1(function callback1() {
    // body of callback1
    wrapper2(function callback2() {
      // body of callback2
      wrapper3(function callback3() {
        // body of callback3
        ...
      })
    });
  });
```

Такую сильно вложенную конструкцию назвали "Ад из колбэков" (**Callback hell**). И она значительно ухудшает читабельность кода.

На смену колбэкам для обработки асинхронных операций пришли промисы. **Promise** - это специальный объект, который имеет одно из двух состояний:

1. Асинхронная операция выполняется:

```
  {
    status: 'pending',
    result: undefined
  }
```

2. Асинхронная операция выполнена с результатом (положительным или ошибкой):

```
  {
    status: 'fulfilled',
    result: value
  }
```

или

```
  {
    status: 'rejected',
    result: error
  }
```

- Названия полей приведены для наглядности.

Промисы имеют несколько методов для обработки, наиболее важный из которых `.then()`. Он принимает 2 колбэка, первый выполнится, если промис завершится с положительным результатом, второй выполнится, если промис завершится с ошибкой. В качестве параметров колбэки принимают результат и ошибку соответственно:

```
  promise.then(
    function(result) {},
    function(error) {}
  );
```

Как видно, промисы все еще тесно связаны с колбэками, но преимуществом промисов перед структурой из колбэков (callback hell) является возможность обрабатывать промисы по цепочке (**chaining**):

```
  promise.then(...).then(...).then(...);
```

Метод `.catch()` позволяет перехватывать ошибки из всех предыдущих промисов в цепочке:

```
  promise.then(...).then(...).then(...).catch(function(error) {});
```

Промисы могут быть включены в состав различных библиотек, в ES6 есть промис для запросов к серверу из браузера (`fetch(...).then(...)`), также промисы можно создавать самостоятельно:

```
 var prom = new Promise(function(resolve, reject) {
   resolve('hello world');
 });
```

Следующий пример демонстрирует асинхронность промисов:

```
  var prom = new Promise(function(resolve, reject) {
    resolve('message 2');
  });

  console.log('message 1');    // 1 - синхронно выведет результат
  prom                         // 2 - синхронно запустит асинхронную операцию
   .then(function(result) {    // ? - асинхронно обработает результат выполнения после всего синхронного кода ("когда-нибудь потом")
     console.log(result);
   });
  console.log('message 3');    // 3 - синхронно выведет результат
```

Т.е. в консоль выведутся сообщения в следующем порядке: 'message 1', 'message 3', 'message 2'.

Пример с MongoDB Native Driver:

```
  client.connect(function(err) { // здесь используется колбэк, хотя возможен и вариант с промисом
    if (err) {
      console.log(err);
    } else {
      console.log('Connected successfully to server'); // 1

      var db = client.db(dbName);                      // 2

      db.stats().then(function(stats) {                // 3 - db.stats()
        console.log(stats);                            // 6 (но теоретически может и 7), когда сервер MongoDB обрабоатет запрос и вернет результат
      });

      var collection = db.collection('clients');       // 4

      collection.count().then(function(count) {        // 5 - collection.count()
        console.log('Clients count: ', count);         // 7 (но теоретически может и 6), когда сервер MongoDB обрабоатет запрос и вернет результат
      });
    }

    client.close();
  });
```

- При использовании нескольких промисов результаты выведутся не в порядке запуска промисов (необязательно в порядке запуска промисов), а в порядке завершения асинхронных операций!

## Обработка ошибок (try ... catch)

### Информационные ресурсы

- Самый главный ресурс по JS ([learn.javascript.ru](https://learn.javascript.ru/))

- Видео-курс от Sorax ([youtube](https://www.youtube.com/playlist?list=PL363QX7S8MfSxcHzvkNEqMYbOyhLeWwem))

- Основы JavaScript от Владилена Милина за 6 часов ([youtube](https://www.youtube.com/watch?v=Bluxbh9CaQ0))

- Основы JS за 90 минут ([youtube](https://www.youtube.com/watch?v=4QHFhIjF2L0))
